const book1 = {
    "0": ["Lorem", "ipsum", "dolor", "sit", "amet"],
    "1": ["consectetur", "adipiscing", "elit"],
    "2": ["Sed", "do", "eiusmod", "tempor"]
};

const book2 = {
    "0": ["Ut", "enim", "ad", "minim", "veniam"],
    "1": ["quis", "nostrud", "exercitation", "ullamco"]
};

const book3 = {
    "0": ["Duis", "aute", "irure", "dolor", "in", "reprehenderit"],
    "1": ["voluptate", "velit", "esse", "Lorem", "dolore"]
};

const book4 = {
    "0": ["Excepteur", "sint", "occaecat", "cupidatat", "non", "proident"],
    "1": ["sunt", "in", "culpa", "qui", "officia"]
};

function buildInvertedIndex(books) {
    const invertedIndex = {};
    for (const bookId in books) {
        const content = books[bookId];
        for (const page in content) {
            const words = content[page].join(' ').toLowerCase().split(/\s+/);
            for (const word of words) {
                if (!invertedIndex[word]) {
                    invertedIndex[word] = [];
                }
                invertedIndex[word].push({ bookId, page });
            }
        }
    }
    return invertedIndex;
}
// Function to search books using inverted index for a phrase
function searchBooksByPhrase(phrase, invertedIndex, books) {
    const searchResults = [];
    const searchWords = phrase.toLowerCase().split(/\s+/);

    // Iterate over each word in the phrase
    for (let i = 0; i <= searchWords.length - 1; i++) {
        const word = searchWords[i];
        if (invertedIndex[word]) {
            // For each occurrence of the current word, check if the subsequent words match
            invertedIndex[word].forEach(({ bookId, page }) => {
                const content = books[bookId][page].join(' ').toLowerCase();
                const startIndex = content.indexOf(word);
                if (startIndex !== -1) {
                    let match = true;
                    // Check subsequent words in the phrase
                    for (let j = 1; j < searchWords.length; j++) {
                        const nextWord = searchWords[i + j];
                        const nextIndex = content.indexOf(nextWord, startIndex + 1);
                        if (nextIndex === -1 || nextIndex !== startIndex + nextWord.length + 1) {
                            match = false;
                            break;
                        }
                    }
                    // If all words in the phrase match consecutively, add to search results
                    if (match) {
                        searchResults.push({ bookId, page, content: books[bookId][page] });
                    }
                }
            });
        }
    }
    return searchResults;
}
const allBooks = {
    "book1": book1,
    "book2": book2,
    "book3": book3,
    "book4": book4
};

// Example usage:
const invertedIndex = buildInvertedIndex(allBooks);
// Example usage:
const phraseSearchTerm = 'lorem ipsum';
const phraseSearchResults = searchBooksByPhrase(phraseSearchTerm, invertedIndex, allBooks);
console.log('Phrase Search Results:', phraseSearchResults);



// Function to save inverted index to a file with compression and Base64 encoding
function saveInvertedIndexToFile(invertedIndex, filename) {
    const invertedIndexJson = JSON.stringify(invertedIndex);
    const compressedData = pako.deflate(invertedIndexJson); // Using pako.js library for compression
    const base64Data = btoa(String.fromCharCode.apply(null, compressedData)); // Encode compressed data to Base64

    const blob = new Blob([base64Data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);
}

// Example usage:
const invertedIndex = buildInvertedIndex(allBooks);
const invertedIndexFilename = 'inverted_index.json';
saveInvertedIndexToFile(invertedIndex, invertedIndexFilename);

////////////rebuild file to invertedIndex
function rebuildInvertedIndex(data) {
    const decodedData = atob(data); // Decode Base64 string
    const decompressedData = pako.inflate(decodedData, { to: 'string' }); // Decompress data
    const invertedIndex = JSON.parse(decompressedData); // Parse JSON string
    return invertedIndex;
}
/////////////////for large data
function saveInvertedIndexToFile(invertedIndex, filename) {
    const invertedIndexJson = JSON.stringify(invertedIndex);
    const chunkSize = 512 * 512; // 1 MB chunk size
    const chunks = [];
    for (let i = 0; i < invertedIndexJson.length; i += chunkSize) {
        const chunk = invertedIndexJson.substring(i, i + chunkSize);
        const compressedData = pako.deflate(chunk); // Compress chunk
        const base64Data = btoa(String.fromCharCode.apply(null, compressedData)); // Encode compressed data to Base64
        chunks.push(base64Data);
    }
    const blob = new Blob(chunks, { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);
}

// Function to generate a large JSON string representing allBooks data
function generateLargeAllBooksString(numBooks, numPages, numWordsPerPage) {
    const allBooks = {};
    for (let i = 1; i <= numBooks; i++) {
        const book = {};
        for (let j = 1; j <= numPages; j++) {
            const page = [];
            for (let k = 1; k <= numWordsPerPage; k++) {
                // Generate random word (for simplicity, using a fixed set of words)
                const word = `word${Math.floor(Math.random() * 1000)}`;
                page.push(word);
            }
            book[j] = page;
        }
        allBooks[`book${i}`] = book;
    }
    return allBooks;
}



// Generate large allBooks string
const numBooks = 10; // Number of books
const numPages = 1000; // Number of pages per book
const numWordsPerPage = 500; // Number of words per page
const allBooks = generateLargeAllBooksString(numBooks, numPages, numWordsPerPage);

// Function to reconstruct the content of a specific book referenced in the inverted index
function reconstructBookFromIndex(bookId, invertedIndex) {
    const bookContent = [];
    // Check each entry in the inverted index
    for (const term in invertedIndex) {
        for (const entry of invertedIndex[term]) {
            if (entry.bookId === bookId) {
               
                bookContent.push(term);
            }
        }
    }
    return bookContent;
}

// Example usage:
const bookId = "book1"; // Replace with the ID of the book you want to reconstruct
const reconstructedBook = reconstructBookFromIndex(bookId, invertedIndex);
console.log("Reconstructed Book:", reconstructedBook);
