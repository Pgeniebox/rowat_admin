<!DOCTYPE html>
<html lang="ar" style="direction: rtl;">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Reader</title>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    
    <script src="https://unpkg.com/bn.js@5.2.1/lib/bn.js"></script>
n*=n*n;
let g=n;
let o = 0;
let k=[];

for (;n/5n>1000000n;n/=5n){o++;
     if(n%5n!==0n){ k=[o,n]}    

  
}
let i =k[0]; let u= k[1];
for (; i > 1; i--) {
    u *= 5n; 
}

let ff= u/k[2];let b=u;let fg=0; k.push(k[2]);
while(ff.toString().length>20){
    if((b+ff)===g){break;}
    fg++;
     b +=ff/2n;
    ff=u/(u/(g-b));
}
if((b+ff)===g){   k.push([fg,(b+ff)===g])     }else{k.push([fg,ff,(b+ff)===g])}

////////////////////////////
let ff= u/k[2];let b=u;let fg=0; k.push(k[2]);
for (let s =0;s<50000n;s++ ){
    if((b+ff)===g){break;}
   if (ff.toString().length<20){break;}
    fg++;
     b +=ff/2n;
    ff=u/(u/(g-b));
}

if((b+ff)===g){   k.push([fg,(b+ff)===g])     }else{k.push([fg,ff,(b+ff)===g])}
</head>
<style>
    body{
        background-color: rgb(34, 34, 34);
        
    }
    .loader {
        top: 0;
        position: fixed;
        
      height: 2px;
      width: 100%;
      --c:no-repeat linear-gradient(#97ff0e 0 0);
      background: var(--c),var(--c),#454446;
      background-size: 60% 100%;
      animation: l16 3s infinite;
    }
    @keyframes l16 {
      0%   {background-position:-150% 0,-150% 0}
      66%  {background-position: 250% 0,-150% 0}
      100% {background-position: 250% 0, 250% 0}
    }



</style>
<body>
    <div class="loader"></div> 

    <input type="text" id="searchInput" placeholder="Type a character">
    <button onclick="searchEntries(document.querySelector('#searchInput').value)">create Lib</button>
    <button id="2" onclick="compressLib(document.querySelector('#searchInput').value)" style="display: block;">compress Lib</button>
    <button id="3" onclick="binToMap(document.querySelector('#searchInput').value)" style="display: block;">binTo Map</button>
    <button id="4" onclick="searchLib(document.querySelector('#searchInput').value)" style="display: block;">search in Map</button>
    <button id="4" onclick="searchBook(document.querySelector('#searchInput').value)" style="display: block;">search Book</button>
    <button id="5" onclick="createAutLib(document.querySelector('#searchInput').value)" style="display: block;">createAutLib</button>
    <button id="5" onclick="sendStr(document.querySelector('#searchInput').value)" style="display: block;">send String</button>

    <div id="result"></div>
   <script type="module">        import { Fireworks } from 'https://esm.run/fireworks-js';
</script>
  
    <script >
        


        document.querySelector('.loader').style.display='none';

       let af=0; 
  

       const originalFetch = window.fetch;

// Override the global fetch function
window.fetch = function(...args) {
    document.querySelector('.loader').style.display='';

    // Add your custom logic here
    console.log('Fetch called with arguments:', args);

    // Call the original fetch function
    return originalFetch(...args).then(response => {
        // You can manipulate the response here if needed
        return response;
    }).catch(error => {
        // Handle errors if needed
        console.error('Fetch error:', error);
        throw error; // Re-throw the error after logging it
    }).finally(()=>{        document.querySelector('.loader').style.display='none';
});
};
       // Save a reference to the original postMessage method
var originalPostMessage = Worker.prototype.postMessage;

// Override the postMessage method of Worker instances
Worker.prototype.postMessage = function() {
    // Show loader
    document.querySelector('.loader').style.display = 'block';

    // Call the original postMessage method with the provided arguments
    originalPostMessage.apply(this, arguments);
};


const worker = new Worker('worker.js');

worker.onmessage = function(e) {
   switch(e.data.action){
case 'blob':
const a = document.createElement('a');
    a.href = e.data.url;
    a.download = e.data.fn;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(e.data.url);
    break;
    case 'error':
        console.log(e.data.er);
        break;
        case 'message':
            console.log(e.data.c);
            break;
            case 'searchResult':
                 const w = performance.now()-af;
                console.log(e.data.response,w);
                break;
   }
   document.querySelector('.loader').style.display='none';

};

async function sendStr(e){
    const response = await fetch(e);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    console.log('wait');
    const arrayBuffer = await response.text();
    console.log('1');
    
    worker.postMessage({action:'mapStr',c:arrayBuffer});

}
function compressLib(e){
    worker.postMessage({action:'compressLib',path:e})
}
function binToMap(e){
   worker.postMessage({action:'binToMap',path:e});
}

function searchLib(e){af=performance.now();
worker.postMessage({action:'searchLib',w:e});
}
function searchBook(e){
worker.postMessage({action:'searchBook',w:e});
}

let Lib;

let lib0 = new Map();
let libAut = new Map();
///lib0.set('TC',new Set());
lib0.set(lib0.size,[]);



      async function searchEntries(e) {

    const fileList = await getFileList(e); 
    for (const fileName of fileList) {
        try {
            const response = await fetch(`${fileName}`);
            const data = await response.text();
            const parser = new DOMParser();
            const htmlDocument = parser.parseFromString(data, "text/html");
            const aut = htmlDocument.querySelector('.footnote').textContent.replace('(','').replace(')','');
const bk = htmlDocument.querySelector('title').textContent;
var check;
var laut = localStorage.getItem('aut')||'';
var aid;
undefined===lib0.get(1)[0]?(aid=1,lib0.set(aid,[aut])):aid=0;
if(aid==0){console.log('0');
for (let o = 1; o < lib0.size; o++) {
   if( lib0.get(o)[0].includes(aut)||aut.includes(lib0.get(o)[0])){ aid=o; break;  }else{aid=lib0.size}
}  console.log('1');
if(aid===lib0.size){lib0.set(aid,[aut]);}
console.log('2');
}
if(!laut.includes(aut)){    laut = laut +' '+aut;
localStorage.setItem('aut',laut);                          }
console.log('3');


lib0.get(aid).push([bk]);
const bid = lib0.get(aid).length-1;
lib0.get(aid)[bid].push({aid:aid});
lib0.get(aid)[bid][1]['bid'] = bid;
console.log('4');

const crd = htmlDocument.querySelector('.PageText');
const crdc = crd.childNodes;

var c =[];
for (let i = 0; i < crdc.length; i++) {
   var e = crdc[i].querySelector('.title');   
  
    if(null!==e){
       var t = e.textContent;
        c.push(t,crdc[i].textContent.replace(t,''));
        ///lib0.get('TC').add(t.replace(':',''));console.log('5');

    }else{
       c.push(crdc[i].textContent)
    }
}
lib0.get(aid)[bid][1]['d'] = c;

htmlDocument.querySelector('.PageText').remove();

let tt = htmlDocument.querySelectorAll('.PageText');
tt.forEach(t=>{const u = t.querySelector('.PageNumber'); if(u){t.data =u.textContent;const d = t.querySelector('.PageHead');if(d){t.removeChild(d)}}});

lib0.get(aid)[bid][1]['p'] = {};
const p = lib0.get(aid)[bid][1].p;
for (let i = 0; i < tt.length; i++) {
    
    const ee = tt[i].data;
    if(ee&&undefined!==ee){
          p[Object.entries(p).length] = {c: ee , a: aid,b: bid,t:'np'}; }
     const ff = tt[i].childNodes;
  
const processedNodes = new Set();
for (let f = 0; f < ff.length; f++) {
    if(ff[f].data&&ff[f].data=='&zwnj;'){continue;}

    if(ff[f].nodeName==='HR'){continue;}
    if (ff[f].className !== 'footnote' && ff[f].nodeName !== 'P' && ff[f].className !== 'title' && !processedNodes.has(ff[f])) {
        
        let combinedText = ff[f].data || ff[f].textContent;
        processedNodes.add(ff[f]);

        let a = ff[f].nextSibling;
        while (a && (a.className !== 'footnote' && a.nodeName !== 'P' && a.className !== 'title'&&a.nodeName!=='HR')) {
            combinedText += (a.data || a.textContent || '');
            processedNodes.add(a);
            a = a.nextSibling;
        }

        if (combinedText.length > 0) {
          p[Object.entries(p).length]={c: combinedText , a: aid,b: bid,t:''}; 
        }
    }
    else if (ff[f].nodeName === 'P' && !processedNodes.has(ff[f])) {
        let combinedText = ff[f].textContent;
        processedNodes.add(ff[f]);

        let a = ff[f].nextSibling;
        while (a && (a.className !== 'footnote' && a.nodeName !== 'P' && a.className !== 'title'&&a.nodeName!=='HR')) {
            combinedText += (a.data || a.textContent || '');
            processedNodes.add(a);
            a = a.nextSibling;
        }

        if (combinedText.length > 0) {
          p[Object.entries(p).length]={ c: combinedText , a: aid,b: bid,t:'bs'}; 
        }
    }
     else if (ff[f].className === 'title') {
          p[Object.entries(p).length]={c: ff[f].textContent , a: aid,b: bid,t:'t'}; 
        }

       else if (ff[f].hasAttribute && ff[f].hasAttribute('data-type')) {
         p[Object.entries(p).length]={c: ff[f].textContent , a: aid,b: bid,t:'t'}; 
        }

      else  if (ff[f].className === 'footnote') {
          const rr =  ff[f].querySelectorAll('p');
rr.forEach(y=>{
    let ddd ='';
    while(y.nextSibling&&y.nextSibling.tagName!=='P'){
    if(y.nextSibling.nodeName==='P'){return;}
    const a = y.nextSibling;
         ddd += (a.data || a.textContent || ''); 
        a.parentElement.removeChild(a);}  
            if(ddd.length>0){y.textContent += 'bs'+ddd}
});
          p[Object.entries(p).length]={c:ff[f].textContent , a: aid,b: bid,t:'fn'}; 
        }
else if(ff[f].textContent>0){
          p[Object.entries(p).length]={c:ff[f].textContent , a: aid,b: bid,t:'v'}; 
}
    }
}

        } catch (error) {
          
           console.log(`Error reading file ${fileName}:`+error.message);
            return;
        }
    }
console.log('creation finished');
 
worker.postMessage({action:'mapStr',c:JSON.stringify( Array.from(lib0.entries()))});
}

async function getFileList(directory) {
            
            let folderlist = [];
let fileList = [];
            let dd;
            
          async function next(e){        
            const response = await fetch(e);
            const data = await response.text();
            const parser = new DOMParser();
            const htmlDocument = parser.parseFromString(data, "text/html");
            ///ii = parser.parseFromString(data, "text/html");
            htmlDocument.querySelector('a').remove();
            
            const links = htmlDocument.querySelectorAll("a");
           return links;
           
                                   }
  async function d(t){
         dd =  await next(t);
         dd.forEach(link => {
                let fileName = link.getAttribute("href");
               if(!fileName.includes('step1')){ if(fileName.includes('.htm')){   fileList.push(fileName); }else{  folderlist.push(fileName);  }}
            });
        }
       await d(directory);
      


            if(folderlist.length>0){  
  folderlist.forEach(async f=>{const a = f;  await d(a);});
        }
            return fileList;
        }

        function binToM(e){

(async () => {
try {
    console.log('fetching');

    const response = await fetch(e);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    console.log('wait');
    // Read the response as an ArrayBuffer
    const arrayBuffer = await response.arrayBuffer();
    console.log('1');

    // Convert the ArrayBuffer to a Uint8Array
    const compressedUint8Array = new Uint8Array(arrayBuffer);
    console.log('2');

    // Decompress the binary data using Pako
    const decompressedUint8Array = pako.inflate(compressedUint8Array);
    console.log('3');

    // Convert the decompressed Uint8Array back to a string
    const originalString = uint8ArrayToString(decompressedUint8Array);
    console.log('4');

    // Log the original string to console or use it as needed
    ///lib0 = await JSON.parse(originalString);
    console.log('5');
   uu = originalString;
    
} catch (error) {
    console.log(error)
}
})();
}
let uu;
function uint8ArrayToString(arr) {
    // Use TextDecoder to convert the Uint8Array to a UTF-8 string
    const decoder = new TextDecoder('utf-8');
    return decoder.decode(arr);
}

async function modFile(e){
    const fileList = await getFileList(e); 
    for (const fileName of fileList) {
        try {
            const response = await fetch(`${fileName}`);
            const data = await response.text();
            const parser = new DOMParser();
            const htmlDocument = parser.parseFromString(data, "text/html");
            const aut = htmlDocument.querySelector('.footnote').textContent.replace('(','').replace(')','');
const bk = htmlDocument.querySelector('title').textContent;}catch(e){console.log(e,fileName);}
const blob = new Blob([data], { type: 'text/html' });

// Create a temporary anchor element
const anchor = document.createElement('a');
anchor.href = URL.createObjectURL(blob);
anchor.download = aut+'-'+bk-'.htm'; // Specify the filename you want

// Programmatically click the anchor to trigger the download
anchor.click();

// Clean up by revoking the object URL
URL.revokeObjectURL(anchor.href);
}

}
let map =  new Map(JSON.parse(localStorage.getItem('map')))|| new Map();
let map2 = new Map(JSON.parse(localStorage.getItem('map2')))|| new Map();
let map3 =  new Map(JSON.parse(localStorage.getItem('map3')))|| new Map();
let map4 = new Map(JSON.parse(localStorage.getItem('map4')))|| new Map();
function skipNumbersWithOne(currentNumber) {
    var i = currentNumber;
    var s = String(i);
    while (s.includes('0')) {
        i++;
        s = String(i);
    }
    return i;
}
let ff=false;
function stringToUint8Array(str) {
    // Pad the string with spaces until its length is divisible by 7
    while (str.length % 7 !== 0) {
        str += ' ';
    }
    let mm;
    let set = new Set(str);
    let i = 1;
    if(!ff){           for (const f of set) {
        map.set(f, String(i));
        map2.set(String(i), f);
        i = skipNumbersWithOne(++i);
        mm=map;
    }        }else{
        for (const f of set) {
        map3.set(f, String(i));
        map4.set(String(i), f);
        i = skipNumbersWithOne(++i);
    }
   /// console.log(str);return;
    mm = map3;
    }
   
    
    
    const arr = [];
    let o = 0;
    for (let i = 0; i < str.length / 7; i++) {
        const g = Number(`${mm.get(str[o])}0${mm.get(str[o + 1])}0${mm.get(str[o + 2])}0${mm.get(str[o + 3])}0${mm.get(str[o + 4])}0${mm.get(str[o + 5])}0${mm.get(str[o + 6])}`);
        arr[i] = g;
        o += 7; 
    }
    if(ff){return arr;}
  ff = true;
    // Split the array into smaller arrays with a maximum length of 10000 elements
    const result = [];
    const maxLength = 10000;
    for (let i = 0; i < arr.length; i += maxLength) {
        result.push(arr.slice(i, i + maxLength));
    }
    const fresult = [];
    for (let f = 0; f < result.length; f ++) {
      fresult.push(numbersToBigInt(result[f]));
    }
    localStorage.setItem('frs',fresult.length);
    console.log(fresult);
   const ffr = numbersToBigInt(fresult);
    ///console.log(fresult);
    ///return console.log(numbersToBigInt( new BN( ffr).words));
     ///ffrs = fresult.map(e=>{return String(e)});
    ///console.log(ffr);
    return ffr.toString();
}


function numbersToBigInt(numbers) {
    let result = 0n; // Initialize BigInt
    const bitLength = 64; // Each number occupies 64 bits

    for (let i = 0; i < numbers.length; i++) {
        let value = BigInt(numbers[i]);
        result += value << BigInt(i * bitLength); // Shift and accumulate
    }

    return result;
}

function bigIntToNumbers(bigIntValue, count) {
    const numbers = [];
    const bitLength = 2048; // The bit length used in the original combination

    for (let i = 0; i < count; i++) {
        let mask = (1n << BigInt(bitLength)) - 1n; // Create a mask for the current segment
        let value = (bigIntValue >> BigInt(i * bitLength)) & mask; // Extract the current segment
        numbers.push(value); // Store the segment as BigInt
    }

    return numbers;
}

function stringToUint8(str) {
    const utf8 = unescape(encodeURIComponent(str));
    const arr = new Uint8Array(utf8.length);
    for (let i = 0; i < utf8.length; i++) {
        arr[i] = utf8.charCodeAt(i);
    }
    return arr;
}

function compressLib(e,b){
    ///document.querySelector('.loader').style.display='';


    (async () => {
        const inputBinary = stringToUint8Array(e);
        document.querySelector('.loader').style.display='none';
         ///const dd = String(inputBinary);
         ///console.log(dd);
         
        const compressedUint8Array = pako.deflate(removeNonNumericCharacters(inputBinary), { level: 9 });
        console.log('5');
    
    const blob = new Blob([compressedUint8Array], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = b;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    localStorage.setItem('map',JSON.stringify(Array.from(map)));
    localStorage.setItem('map2',JSON.stringify(Array.from(map2)));
    localStorage.setItem('map3',JSON.stringify(Array.from(map3)));
    localStorage.setItem('map4',JSON.stringify(Array.from(map4)));
        console.log('finish');
    })();
    
    }
function btostr(e){
    (async () => {
try {
    console.log('fetching');

    const response = await fetch(e);
    if (!response.ok) {
        throw new Error('Network response was not ok');
    }
    console.log('wait');
    // Read the response as an ArrayBuffer
    const compressedUint8Array = await response.arrayBuffer(); // Convert the response to an ArrayBuffer
    const decompressedUint8Array = pako.inflate(compressedUint8Array); // Decompress the data
    let decompressedString = '';
    for (let i = 0; i < decompressedUint8Array.length; i++) {
        decompressedString += String.fromCharCode(decompressedUint8Array[i]);
    }
    ///console.log(JSON.parse('['+decompressedString+']'));return;
    // You now have the decompressed Uint8Array, you can convert it to Uint32Array if needed
   ///const big1 = JSON.parse('['+decompressedString+']');
let gg;
gg = removeNonNumericCharacters(decompressedString);




   ///vd = new BN(gg);
    ///let vv = bigIntToNumbers(gg,Number(localStorage.getItem('frs')));
    console.log(bigIntToNumbers(BigInt(gg),Number(localStorage.getItem('frs'))));
} catch (error) {
    console.log(error)
}
})();

}
function removeNonNumericCharacters(str) {
    // Use a regular expression to match any non-numeric characters and replace them with an empty string
    return str.replace(/\D/g, '');
}
let vd;
        function op(){
            var n =1126954000000000000000n;
let i = 0;
while (n % 2n !== 1n) {
        n = n/2n;
        i++; 
    }

while (i > 0) {
    n *= 2n;
    i--;
}

console.log(n);
        }
        var n = 0n;
n += 1000000000000000000000000000000000000000000000000000n; 
let g=n;
let o = 0;
let h;
var p=0;
let k=[];
let fg=false;
for (;n/2n>1000n;n/=2n){
     if(n%2n!==0n){fg=true; h=[o,n,BigInt(p * Math.pow(100, p.toString().length-2)),p]; p+=1;}    o++;

   if(fg){ p/=2;k.push(p)} 
}
let i =h[0]; let u=h[1];let b=h[2]+h[2]/10000000000000000n;
for (; i > 0; i--) {
    u *= 2n; 
        b *= 2n;
}
b/=100000000000000000000000000000000n;console.log(g-u,b)
        let n=100000000000000000000000n
let g=n;
let p=0n
let o=0;
let ok =false;
let u=[];
let f=0;
var r=0n
for (;n/2n>1n;n/=2n){o++;   p*=5n; 
                 if(ok){   ok=false; p+= r;u.push([n,p,o,r]);   }    
     if(n%2n!==0n){ ok=true;
         if(p.toString()[0]==='1'){console.log('1');   r =BigInt(5* Math.pow(10, p.toString().length));                   }else{
console.log('0');
              r =BigInt(5* Math.pow(10, p.toString().length));
         }
         
            ok=true;  
                 } 
                 
}
n=u[u.length-1][0];p=u[u.length-1][1];o=u[u.length-1][2];
    
for (; o > 1; o--) {
   n*=2n;p*=2n
}
console.log(p,g-n)
    </script>
</body>
</html>
